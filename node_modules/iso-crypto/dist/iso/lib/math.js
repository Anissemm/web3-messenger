export const curves = {
    p256: {
        p: 2n ** 224n * (2n ** 32n - 1n) + 2n ** 192n + 2n ** 96n - 1n,
        a: 0xffffffff_00000001_00000000_00000000_00000000_ffffffff_ffffffff_fffffffcn,
        b: 0x5ac635d8_aa3a93e7_b3ebbd55_769886bc_651d06b0_cc53b0f6_3bce3c3e_27d2604bn,
        g: {
            x: 0x6b17d1f2_e12c4247_f8bce6e5_63a440f2_77037d81_2deb33a0_f4a13945_d898c296n,
            y: 0x4fe342e2_fe1a7f9b_8ee7eb4a_7c0f9e16_2bce3357_6b315ece_cbb64068_37bf51f5n
        }
    },
    p384: {
        p: 2n ** 384n - 2n ** 128n - 2n ** 96n + 2n ** 32n - 1n,
        a: 0xffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_fffffffe_ffffffff_00000000_00000000_fffffffcn,
        b: 0xb3312fa7_e23ee7e4_988e056b_e3f82d19_181d9c6e_fe814112_0314088f_5013875a_c656398d_8a2ed19d_2a85c8ed_d3ec2aefn,
        g: {
            x: 0xaa87ca22_be8b0537_8eb1c71e_f320ad74_6e1d3b62_8ba79b98_59f741e0_82542a38_5502f25d_bf55296c_3a545e38_72760ab7n,
            y: 0x3617de4a_96262c6f_5d9e98bf_9292dc29_f8f41dbd_289a147c_e9da3113_b5f0b8c0_0a60b1ce_1d7e819d_7a431d7c_90ea0e5fn
        }
    },
    p521: {
        p: 2n ** 521n - 1n,
        a: 0x1ff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_ffffffff_fffffffcn,
        b: 0x51_953eb961_8e1c9a1f_929a21a0_b68540ee_a2da725b_99b315f3_b8b48991_8ef109e1_56193951_ec7e937b_1652c0bd_3bb1bf07_3573df88_3d2c34f1_ef451fd4_6b503f00n,
        g: {
            x: 0xc6_858e06b7_0404e9cd_9e3ecb66_2395b442_9c648139_053fb521_f828af60_6b4d3dba_a14b5e77_efe75928_fe1dc127_a2ffa8de_3348b3c1_856a429b_f97e7e31_c2e5bd66n,
            y: 0x118_39296a78_9a3bc004_5c8a5fb4_2c7d1bd9_98f54449_579b4468_17afbd17_273e662c_97ee7299_5ef42640_c550b901_3fad0761_353c7086_a272c240_88be9476_9fd16650n
        }
    }
};
const euclidian = (a, b)=>{
    const pairs = [];
    let oldA = a;
    let oldB = b;
    let mod = a % b;
    while(mod > 1n){
        pairs.push({
            a: oldA,
            b: oldB
        });
        mod = oldB % oldA;
        oldB = oldA;
        oldA = mod;
    }
    let x = 1n;
    let y = 0n;
    let pair = pairs.pop();
    while(pair){
        y = x;
        x = (1n - pair.b * y) / pair.a;
        pair = pairs.pop();
    }
    return {
        x,
        y
    };
};
const modularInverse = (a, mod)=>{
    const inverse = euclidian(a < 0n ? a + mod : a, mod).x;
    if (inverse < 0n) {
        return inverse + mod;
    }
    return inverse;
};
const positiveMod = (x, mod)=>{
    const result = x % mod;
    if (result < 0n) {
        return result + mod;
    }
    return result;
};
const addPoints = (p, q, curve)=>{
    const { rise, run } = p.x === q.x ? {
        rise: 3n * p.x * p.x + curve.a,
        run: 2n * p.y
    } : {
        rise: q.y - p.y,
        run: q.x - p.x
    };
    const slope = rise * modularInverse(run, curve.p) % curve.p;
    const x = positiveMod(slope * slope - q.x - p.x, curve.p);
    return {
        x,
        y: positiveMod(slope * p.x - slope * x - p.y, curve.p)
    };
};
export const derivePublicKey = (privateKey, curve)=>{
    const bits = [
        ...privateKey.toString(2)
    ].reverse();
    let doublePoint = null;
    let sum = null;
    for (const bit of bits){
        doublePoint = doublePoint ? addPoints(doublePoint, doublePoint, curve) : curve.g;
        if (bit === '1') {
            sum = sum ? addPoints(sum, doublePoint, curve) : doublePoint;
        }
    }
    return sum;
};
const power = (x, y, p)=>{
    let res = 1n;
    let x2 = x;
    const bits = [
        ...y.toString(2)
    ].reverse();
    for (const bit of bits){
        if (bit === '1') {
            res = res * x2 % p;
        }
        x2 = x2 * x2 % p;
    }
    return res;
};
const modSqrt = (n, p)=>{
    let s = 1n;
    while((p - 1n) % 2n ** s === 0n){
        ++s;
    }
    --s;
    const q = (p - 1n) / 2n ** s;
    let z = 1n;
    let res = power(z, (p - 1n) / 2n, p);
    while(res !== p - 1n){
        ++z;
        res = power(z, (p - 1n) / 2n, p);
    }
    let c = power(z, q, p);
    let r = power(n, (q + 1n) / 2n, p);
    let t = power(n, q, p);
    let m = s;
    while(t !== 1n){
        let i = 1n;
        let t2 = t * t % p;
        while(t2 !== 1n){
            t2 = t2 * t2 % p;
            ++i;
        }
        const b = power(c, power(2n, m - i - 1n, p), p);
        r = r * b % p;
        c = b * b % p;
        t = t * c % p;
        m = i;
    }
    return r;
};
export const deriveYCoordinate = (x, odd, curve)=>{
    const y = modSqrt(x ** 3n + curve.a * x + curve.b, curve.p);
    const isOdd = !!(y & 1n);
    return isOdd === odd ? y : curve.p - y;
};

//# sourceMappingURL=math.js.map