import { inputToEncoding } from './lib/input-to-encoding.js';
import { defaultEncoding, Encodings } from './lib/types.js';
const BITS_PER_HEX = 4;
const HEX_SIZE = 16;
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const { atob, btoa } = globalThis;
const base64url = (text)=>text.replaceAll('=', '').replaceAll('+', '-').replaceAll('/', '_');
const EXTRA_EQUALS = '====';
const base64standard = (text)=>{
    const charReplaced = text.replaceAll('-', '+').replaceAll('_', '/');
    let appendEquals = charReplaced + '='.repeat((BITS_PER_HEX - text.length % BITS_PER_HEX) % BITS_PER_HEX);
    while(appendEquals.endsWith(EXTRA_EQUALS)){
        appendEquals = appendEquals.slice(0, -EXTRA_EQUALS.length);
    }
    return appendEquals;
};
const toBase64 = (buf)=>base64url(btoa(String.fromCodePoint(...new Uint8Array(buf))));
const fromBase64 = (str)=>Uint8Array.from(atob(base64standard(str)), (x)=>x.codePointAt(0));
const toHex = (buf)=>[
        ...buf
    ].map((x)=>x.toString(HEX_SIZE).padStart(2, '0')).join('');
const fromHex = (str)=>{
    const length = str.length % 2 ? str.length + 1 : str.length;
    return new Uint8Array((str.padStart(length, '0').match(/.{2}/gu) ?? []).map((byte)=>Number.parseInt(byte, HEX_SIZE)));
};
export const decode = (input)=>{
    const { encoding, text } = inputToEncoding(input);
    if (encoding === Encodings.RAW) {
        return text;
    }
    if (encoding === Encodings.UTF8) {
        return encoder.encode(text);
    }
    if (encoding === Encodings.HEX) {
        return fromHex(text);
    }
    return fromBase64(text);
};
export const encode = (input, encoding = defaultEncoding)=>{
    const buffer = decode(input);
    if (encoding === Encodings.UTF8) {
        return decoder.decode(buffer);
    }
    if (encoding === Encodings.HEX) {
        return toHex(buffer);
    }
    const url = toBase64(buffer);
    if (encoding === Encodings.BASE64) {
        return base64standard(url);
    }
    return url;
};

//# sourceMappingURL=encode.js.map