import { decode, encode } from '#encode';
import { padBytes } from '../lib/bytes-length.js';
import { curves, deriveYCoordinate } from '../lib/math.js';
import { eccMeta } from '../lib/size-meta.js';
import { defaultCurve, Encodings } from '../lib/types.js';
const HEX_SIZE = 16;
const DECOMPRESSED_KEY_PREFIX = 4;
export const compressEccPublicKey = (publicKey, curve = defaultCurve)=>{
    const decoded = decode(publicKey);
    const { bytes } = eccMeta(curve);
    if (decoded.length <= bytes + 1) {
        return decoded;
    }
    const x = decoded.slice(1, bytes + 1);
    const odd = decoded.slice(bytes + 1).reverse()[0] & 1;
    return new Uint8Array([
        2 + odd,
        ...x
    ]);
};
export const decompressEccPublicKey = (publicKey, curve = defaultCurve)=>{
    const decoded = decode(publicKey);
    const { bytes } = eccMeta(curve);
    if (decoded.length > bytes + 1) {
        return decoded;
    }
    const x = decoded.slice(1);
    const odd = !!(decoded[0] & 1);
    const y = deriveYCoordinate(BigInt(`0x${encode(x, Encodings.HEX)}`), odd, curves[curve]);
    return new Uint8Array([
        DECOMPRESSED_KEY_PREFIX,
        ...x,
        ...padBytes(decode({
            text: y.toString(HEX_SIZE),
            encoding: Encodings.HEX
        }), bytes)
    ]);
};

//# sourceMappingURL=compression.js.map