import "./chunk-PR4QN5HX.js";

// ../node_modules/iso-crypto/dist/iso/lib/input-to-encoding.js
var inputToEncoding = (input) => {
  if (typeof input === "string") {
    return {
      text: input,
      encoding: "utf8"
    };
  }
  if (input instanceof Uint8Array) {
    return {
      text: input,
      encoding: "raw"
    };
  }
  return input;
};

// ../node_modules/iso-crypto/dist/iso/lib/types.js
var Ciphers = function(Ciphers2) {
  Ciphers2["AES"] = "AES";
  return Ciphers2;
}({});
var Modes = function(Modes2) {
  Modes2["CBC"] = "CBC";
  Modes2["CTR"] = "CTR";
  return Modes2;
}({});
var Sizes = function(Sizes2) {
  Sizes2[Sizes2["KEY_128"] = 128] = "KEY_128";
  Sizes2[Sizes2["KEY_160"] = 160] = "KEY_160";
  Sizes2[Sizes2["KEY_192"] = 192] = "KEY_192";
  Sizes2[Sizes2["KEY_256"] = 256] = "KEY_256";
  Sizes2[Sizes2["KEY_384"] = 384] = "KEY_384";
  Sizes2[Sizes2["KEY_512"] = 512] = "KEY_512";
  return Sizes2;
}({});
var defaultEncryption = {
  cipher: "AES",
  size: 256,
  mode: "CTR"
};
var Algorithms = function(Algorithms2) {
  Algorithms2["SHA1"] = "SHA1";
  Algorithms2["SHA2"] = "SHA2";
  Algorithms2["RAW"] = "raw";
  return Algorithms2;
}({});
var defaultHash = {
  algorithm: "SHA2",
  size: 256
};
var Encodings = function(Encodings2) {
  Encodings2["BASE64"] = "base64";
  Encodings2["BASE64URL"] = "base64url";
  Encodings2["HEX"] = "hex";
  Encodings2["RAW"] = "raw";
  Encodings2["UTF8"] = "utf8";
  return Encodings2;
}({});
var defaultEncoding = "utf8";
var Curves = function(Curves2) {
  Curves2["P256"] = "p256";
  Curves2["P384"] = "p384";
  Curves2["P521"] = "p521";
  return Curves2;
}({});
var defaultCurve = "p256";

// ../node_modules/iso-crypto/dist/iso/encode.js
var BITS_PER_HEX = 4;
var HEX_SIZE = 16;
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var { atob, btoa } = globalThis;
var base64url = (text) => text.replaceAll("=", "").replaceAll("+", "-").replaceAll("/", "_");
var EXTRA_EQUALS = "====";
var base64standard = (text) => {
  const charReplaced = text.replaceAll("-", "+").replaceAll("_", "/");
  let appendEquals = charReplaced + "=".repeat((BITS_PER_HEX - text.length % BITS_PER_HEX) % BITS_PER_HEX);
  while (appendEquals.endsWith(EXTRA_EQUALS)) {
    appendEquals = appendEquals.slice(0, -EXTRA_EQUALS.length);
  }
  return appendEquals;
};
var toBase64 = (buf) => base64url(btoa(String.fromCodePoint(...new Uint8Array(buf))));
var fromBase64 = (str) => Uint8Array.from(atob(base64standard(str)), (x) => x.codePointAt(0));
var toHex = (buf) => [
  ...buf
].map((x) => x.toString(HEX_SIZE).padStart(2, "0")).join("");
var fromHex = (str) => {
  const length = str.length % 2 ? str.length + 1 : str.length;
  return new Uint8Array((str.padStart(length, "0").match(/.{2}/gu) ?? []).map((byte) => Number.parseInt(byte, HEX_SIZE)));
};
var decode = (input) => {
  const { encoding, text } = inputToEncoding(input);
  if (encoding === Encodings.RAW) {
    return text;
  }
  if (encoding === Encodings.UTF8) {
    return encoder.encode(text);
  }
  if (encoding === Encodings.HEX) {
    return fromHex(text);
  }
  return fromBase64(text);
};
var encode = (input, encoding = defaultEncoding) => {
  const buffer = decode(input);
  if (encoding === Encodings.UTF8) {
    return decoder.decode(buffer);
  }
  if (encoding === Encodings.HEX) {
    return toHex(buffer);
  }
  const url = toBase64(buffer);
  if (encoding === Encodings.BASE64) {
    return base64standard(url);
  }
  return url;
};

// ../node_modules/iso-crypto/dist/iso/hash/browser.js
var { crypto } = globalThis;
var hashAlgorithm = ({ algorithm, size }) => {
  if (algorithm === Algorithms.SHA1) {
    return "SHA-1";
  }
  return `SHA-${size}`;
};
var hash = async (input, algorithm = defaultHash) => {
  const decoded = decode(input);
  if (algorithm === Algorithms.RAW) {
    return decoded;
  }
  const buffer = await crypto.subtle.digest(hashAlgorithm(algorithm), decoded);
  return new Uint8Array(buffer);
};

// ../node_modules/iso-crypto/dist/iso/random/browser.js
var { crypto: crypto2 } = globalThis;
var randomBytes = async (size) => crypto2.getRandomValues(new Uint8Array(size));

// ../node_modules/iso-crypto/dist/iso/lib/bytes-length.js
var padBytes = (arr, bytes) => {
  if (arr.length >= bytes) {
    return arr;
  }
  const output = new Uint8Array(bytes);
  const offset = bytes - arr.length;
  for (let i = offset, j = 0; i < bytes; ++i, ++j) {
    output[i] = arr[j];
  }
  return output;
};
var trimBytes = (arr, bytes) => {
  if (arr.length <= bytes) {
    return arr;
  }
  return arr.slice(arr.length - bytes);
};
var fixBytes = (arr, bytes) => padBytes(trimBytes(arr, bytes), bytes);

// ../node_modules/iso-crypto/dist/iso/lib/size-meta.js
var BITS_PER_BYTE = 8;
var BYTE_PAIR = BITS_PER_BYTE * 2;
var encryptionMeta = (encryption) => ({
  secret: encryption.size / BITS_PER_BYTE,
  iv: BYTE_PAIR
});
var eccMeta = (curve) => {
  const bytePairs = Number.parseInt(curve.slice(1), 10) / BYTE_PAIR;
  return {
    bytes: Math.ceil(bytePairs) * 2
  };
};

// ../node_modules/iso-crypto/dist/iso/encrypt/browser.js
var { crypto: crypto3 } = globalThis;
var encryptionToAlgorithm = (encryption) => ({
  name: `${encryption.cipher}-${encryption.mode}`,
  length: encryption.size / 2
});
var encrypt = async ({ data, secret }, { encryption = defaultEncryption, hash: hashAlgorithm2 = defaultHash } = {}) => {
  const sizes = encryptionMeta(encryption);
  const algorithm = encryptionToAlgorithm(encryption);
  const [iv, secretHash] = await Promise.all([
    randomBytes(sizes.iv),
    hash(secret, hashAlgorithm2)
  ]);
  const key = await crypto3.subtle.importKey("raw", fixBytes(secretHash, sizes.secret), algorithm.name, false, [
    "encrypt"
  ]);
  const encrypted = await crypto3.subtle.encrypt({
    ...algorithm,
    counter: iv,
    iv
  }, key, decode(data));
  return {
    encrypted: new Uint8Array(encrypted),
    iv
  };
};
var decrypt = async ({ encrypted, iv, secret }, { encryption = defaultEncryption, hash: hashAlgorithm2 = defaultHash } = {}) => {
  const sizes = encryptionMeta(encryption);
  const algorithm = encryptionToAlgorithm(encryption);
  const hashedSecret = await hash(secret, hashAlgorithm2);
  const key = await crypto3.subtle.importKey("raw", fixBytes(hashedSecret, sizes.secret), algorithm.name, false, [
    "decrypt"
  ]);
  const decodedIv = decode(iv);
  const decrypted = await crypto3.subtle.decrypt({
    ...algorithm,
    counter: decodedIv,
    iv: decodedIv
  }, key, decode(encrypted));
  return new Uint8Array(decrypted);
};

// ../node_modules/iso-crypto/dist/iso/lib/math.js
var curves = {
  p256: {
    p: 2n ** 224n * (2n ** 32n - 1n) + 2n ** 192n + 2n ** 96n - 1n,
    a: 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffcn,
    b: 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bn,
    g: {
      x: 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296n,
      y: 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5n
    }
  },
  p384: {
    p: 2n ** 384n - 2n ** 128n - 2n ** 96n + 2n ** 32n - 1n,
    a: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffcn,
    b: 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aefn,
    g: {
      x: 0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7n,
      y: 0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5fn
    }
  },
  p521: {
    p: 2n ** 521n - 1n,
    a: 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffcn,
    b: 0x51953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00n,
    g: {
      x: 0xc6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66n,
      y: 0x11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650n
    }
  }
};
var euclidian = (a, b) => {
  const pairs = [];
  let oldA = a;
  let oldB = b;
  let mod = a % b;
  while (mod > 1n) {
    pairs.push({
      a: oldA,
      b: oldB
    });
    mod = oldB % oldA;
    oldB = oldA;
    oldA = mod;
  }
  let x = 1n;
  let y = 0n;
  let pair = pairs.pop();
  while (pair) {
    y = x;
    x = (1n - pair.b * y) / pair.a;
    pair = pairs.pop();
  }
  return {
    x,
    y
  };
};
var modularInverse = (a, mod) => {
  const inverse = euclidian(a < 0n ? a + mod : a, mod).x;
  if (inverse < 0n) {
    return inverse + mod;
  }
  return inverse;
};
var positiveMod = (x, mod) => {
  const result = x % mod;
  if (result < 0n) {
    return result + mod;
  }
  return result;
};
var addPoints = (p, q, curve) => {
  const { rise, run } = p.x === q.x ? {
    rise: 3n * p.x * p.x + curve.a,
    run: 2n * p.y
  } : {
    rise: q.y - p.y,
    run: q.x - p.x
  };
  const slope = rise * modularInverse(run, curve.p) % curve.p;
  const x = positiveMod(slope * slope - q.x - p.x, curve.p);
  return {
    x,
    y: positiveMod(slope * p.x - slope * x - p.y, curve.p)
  };
};
var derivePublicKey = (privateKey, curve) => {
  const bits = [
    ...privateKey.toString(2)
  ].reverse();
  let doublePoint = null;
  let sum = null;
  for (const bit of bits) {
    doublePoint = doublePoint ? addPoints(doublePoint, doublePoint, curve) : curve.g;
    if (bit === "1") {
      sum = sum ? addPoints(sum, doublePoint, curve) : doublePoint;
    }
  }
  return sum;
};
var power = (x, y, p) => {
  let res = 1n;
  let x2 = x;
  const bits = [
    ...y.toString(2)
  ].reverse();
  for (const bit of bits) {
    if (bit === "1") {
      res = res * x2 % p;
    }
    x2 = x2 * x2 % p;
  }
  return res;
};
var modSqrt = (n, p) => {
  let s = 1n;
  while ((p - 1n) % 2n ** s === 0n) {
    ++s;
  }
  --s;
  const q = (p - 1n) / 2n ** s;
  let z = 1n;
  let res = power(z, (p - 1n) / 2n, p);
  while (res !== p - 1n) {
    ++z;
    res = power(z, (p - 1n) / 2n, p);
  }
  let c = power(z, q, p);
  let r = power(n, (q + 1n) / 2n, p);
  let t = power(n, q, p);
  let m = s;
  while (t !== 1n) {
    let i = 1n;
    let t2 = t * t % p;
    while (t2 !== 1n) {
      t2 = t2 * t2 % p;
      ++i;
    }
    const b = power(c, power(2n, m - i - 1n, p), p);
    r = r * b % p;
    c = b * b % p;
    t = t * c % p;
    m = i;
  }
  return r;
};
var deriveYCoordinate = (x, odd, curve) => {
  const y = modSqrt(x ** 3n + curve.a * x + curve.b, curve.p);
  const isOdd = !!(y & 1n);
  return isOdd === odd ? y : curve.p - y;
};

// ../node_modules/iso-crypto/dist/iso/ecc/compression.js
var HEX_SIZE2 = 16;
var DECOMPRESSED_KEY_PREFIX = 4;
var compressEccPublicKey = (publicKey, curve = defaultCurve) => {
  const decoded = decode(publicKey);
  const { bytes } = eccMeta(curve);
  if (decoded.length <= bytes + 1) {
    return decoded;
  }
  const x = decoded.slice(1, bytes + 1);
  const odd = decoded.slice(bytes + 1).reverse()[0] & 1;
  return new Uint8Array([
    2 + odd,
    ...x
  ]);
};
var decompressEccPublicKey = (publicKey, curve = defaultCurve) => {
  const decoded = decode(publicKey);
  const { bytes } = eccMeta(curve);
  if (decoded.length > bytes + 1) {
    return decoded;
  }
  const x = decoded.slice(1);
  const odd = !!(decoded[0] & 1);
  const y = deriveYCoordinate(BigInt(`0x${encode(x, Encodings.HEX)}`), odd, curves[curve]);
  return new Uint8Array([
    DECOMPRESSED_KEY_PREFIX,
    ...x,
    ...padBytes(decode({
      text: y.toString(HEX_SIZE2),
      encoding: Encodings.HEX
    }), bytes)
  ]);
};

// ../node_modules/iso-crypto/dist/iso/ecc/browser.js
var BITS_PER_BYTE2 = 8;
var HEX_SIZE3 = 16;
var { crypto: crypto4 } = globalThis;
var curveToKeyParams = (curve) => ({
  name: "ECDH",
  namedCurve: curve.replace("p", "P-")
});
var generateEccPrivateKey = async (curve = defaultCurve) => {
  const ecdh = await crypto4.subtle.generateKey(curveToKeyParams(curve), true, [
    "deriveKey"
  ]);
  const key = await crypto4.subtle.exportKey("jwk", ecdh.privateKey);
  return padBytes(decode({
    text: key.d,
    encoding: Encodings.BASE64URL
  }), eccMeta(curve).bytes);
};
var getPublicKey = (privateKey, curve) => {
  const hex = encode(decode(privateKey), Encodings.HEX);
  return derivePublicKey(BigInt(`0x${hex}`), curves[curve]);
};
var bigIntToBase64Url = (x, bytes) => encode(padBytes(decode({
  text: x.toString(HEX_SIZE3),
  encoding: Encodings.HEX
}), bytes), Encodings.BASE64URL);
var derivePublicKeyBase64 = (privateKey, curve) => {
  const { x, y } = getPublicKey(privateKey, curve);
  const { bytes } = eccMeta(curve);
  return {
    x: bigIntToBase64Url(x, bytes),
    y: bigIntToBase64Url(y, bytes)
  };
};
var generateEccPublicKey = (privateKey, curve = defaultCurve) => {
  const { x, y } = getPublicKey(privateKey, curve);
  const { bytes } = eccMeta(curve);
  return new Uint8Array([
    2 + Number(y & 1n),
    ...padBytes(decode({
      text: x.toString(HEX_SIZE3),
      encoding: Encodings.HEX
    }), bytes)
  ]);
};
var eccSecret = async ({ curve, privateKey, publicKey }) => {
  const bufferPrivateKey = decode(privateKey);
  const curveParams = curveToKeyParams(curve);
  const [privateEc, publicEc] = await Promise.all([
    crypto4.subtle.importKey("jwk", {
      crv: curveParams.namedCurve,
      kty: "EC",
      d: encode(bufferPrivateKey, Encodings.BASE64URL),
      ...derivePublicKeyBase64(bufferPrivateKey, curve)
    }, curveParams, true, [
      "deriveKey"
    ]),
    crypto4.subtle.importKey("raw", decompressEccPublicKey(publicKey, curve), curveParams, true, [])
  ]);
  const { bytes } = eccMeta(curve);
  const derivedSecret = await crypto4.subtle.deriveKey({
    name: "ECDH",
    public: publicEc
  }, privateEc, {
    name: "HMAC",
    hash: "SHA-256",
    length: bytes * BITS_PER_BYTE2
  }, true, [
    "sign"
  ]);
  const secret = await crypto4.subtle.exportKey("raw", derivedSecret);
  return {
    secret: new Uint8Array(secret),
    privateEc
  };
};
var eccEncrypt = async ({ data, publicKey, privateKey }, { curve = defaultCurve, encryption = defaultEncryption } = {}) => {
  const secretKey = await eccSecret({
    curve,
    privateKey,
    publicKey
  });
  const [encrypted, jwk] = await Promise.all([
    encrypt({
      data,
      secret: secretKey.secret
    }, {
      encryption,
      hash: Algorithms.RAW
    }),
    crypto4.subtle.exportKey("jwk", secretKey.privateEc)
  ]);
  const odd = decode({
    text: jwk.y,
    encoding: Encodings.BASE64URL
  }).reverse()[0] & 1;
  const publicX = decode({
    text: jwk.x,
    encoding: Encodings.BASE64URL
  });
  const { bytes } = eccMeta(curve);
  return {
    ...encrypted,
    publicKey: new Uint8Array([
      2 + odd,
      ...padBytes(publicX, bytes)
    ])
  };
};
var eccDecrypt = async ({ encrypted, iv, publicKey, privateKey }, { curve = defaultCurve, encryption = defaultEncryption } = {}) => {
  const { secret } = await eccSecret({
    curve,
    privateKey,
    publicKey
  });
  return decrypt({
    encrypted,
    iv,
    secret
  }, {
    encryption,
    hash: Algorithms.RAW
  });
};

// ../node_modules/iso-crypto/dist/encode.js
var decodeObject = (obj, encoding = defaultEncoding) => {
  const result = {};
  for (const [key, text] of Object.entries(obj)) {
    result[key] = decode({
      text,
      encoding
    });
  }
  return result;
};
var encodeObject = (obj, encoding) => {
  const result = {};
  for (const [key, arr] of Object.entries(obj)) {
    result[key] = encode(arr, encoding);
  }
  return result;
};
export {
  Algorithms,
  Ciphers,
  Curves,
  Encodings,
  Modes,
  Sizes,
  compressEccPublicKey,
  decode,
  decodeObject,
  decompressEccPublicKey,
  decrypt,
  eccDecrypt,
  eccEncrypt,
  encode,
  encodeObject,
  encrypt,
  generateEccPrivateKey,
  generateEccPublicKey,
  hash,
  randomBytes
};
//# sourceMappingURL=iso-crypto.js.map
